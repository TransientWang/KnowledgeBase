## 判断对象是否存活的算法

主流商用语言的主流实现中，都是通过可达性分析来判定对象是否存活的。这个算法的基本思路就是通过一系列的成为"GC Roots"的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径成为引用链，当一个对象到 GC Roots 没有任何引用链相连（用图论的话说就是从GC Roots 到这个对象不可达）时，则证明此对象是不可用的。

在 java语言中，可作为GC Roots的对象包括下面几种：

- 虚拟机栈（栈帧中的本地变量表）中引用的对象。
- 方法区中静态属性引用的对象
- 方法区中常量引用的对象.
- 本地方法栈中JNI(即一般说的 native 方法) 引用的对象。

还有引用计数法，但是需要解决循环引用的问题（python 就是用的引用计数法）。

## 几种引用

### 可达性

从最强到最弱，不同的可达性水平反映了物体的生命周期。 它们在操作上定义如下：

- 如果某个对象可以在不遍历任何引用对象的情况下到达某个对象，则该对象是强可访问的。 新创建的对象相在创建它的线程上下文中是强可达的。

- 如果一个对象不是强可达的但是可以通过软引用达到那么这个对象是软可达的。
- 如果一个对象既不是强可达也不是软可达，但是可以通过弱引用达到，那么这个对象是弱可达的。 当清除对弱可达对象的弱引用时，该对象就有资格进行终结。
- 如果一个对象既没有强可达，软可达，也没有弱可达，那么该对象是幻像可达的，它已经被终结，并且一些幻像引用指向它。
- 最后，如果无法通过上述任何方式访问对象，则无法访问该对象，因此有资格进行回收。

在 JDK 1.2 之前，java中引用的定义很传统：如果reference 类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表一个引用。在1.2之后，java对引用的概念进行了扩充，将引用分为强引用（Atrong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference） 4 种，这 4 种引用强度依次减弱。

- **强引用**就是指在程序代码中普遍存在的，可以在线程上下文中直接获取到的对象的引用。

- **软引用**，由垃圾收集器根据内存需求自行决定清除。软引用通常用于实现对内存敏感的缓存。

  假设垃圾收集器在某个时间点确定对象是软可达的。此时，它可以选择原子地清除对该对象的所有软引用以及对通过一系列强引用可从该对象到达的任何其他可轻松访问的对象的所有软引用。在同一时间或稍后，**垃圾回收器将已经回收的软引用对象的引用入队到引用队列中，以便将代表软引用对象的引用手动清除**。

  在虚拟机抛出`OutOfMemoryError`之前，垃圾收集器保证已清除对软引用对象的所有软引用。否则，不会对清除软引用的时间或清除对不同对象的一组此类引用的顺序施加约束。但是，鼓励虚拟机实现偏向清除最近创建或最近使用的软引用。

  此类的直接实例可用于实现简单缓存;此类或派生的子类也可用于更大的数据结构，以实现更复杂的高速缓存。只要软引用的引用是强可达的，即实际上是在使用中，软引用就不会被清除。因此，复杂的高速缓存可以例如通过保持对这些条目的强烈指示来防止其最近使用的条目被丢弃，留下剩余的条目由垃圾收集器决定丢弃。

* **弱引用**，它们不会阻止它们的指向对象可被最终结（只要进行垃圾回收就将弱引用回收），终结，然后回收。 弱引用最常用于实现规范化映射。
  假设垃圾收集器在某个时间点确定对象是弱可达的。 然后，他会原子地清除该对象上所有的弱引用，并且通过一个强引用和软引用的引用链来清除所有可达的弱引用。 同时，它将声明所有以前弱可达的对象可以被终结。 在同一时间或稍后，它将使用引用队列注册的新清除的弱引用入队。

* **幻像引用**，在垃圾收集器确定幻像引用对象可以被回收后，将他们压入引用队列。 幻影引用通常用于安排事后清理操作。
  假设垃圾收集器在某个时间点确定对象是幻像可达的。 那时它将原子地清除对该对象的所有幻像引用以及对该对象可从其访问的任何其他可进入幻像的对象的所有幻像引用。 在同一时间或稍后，它将使用参考队列注册的新清除的幻像引用入队。

  为了确保可回收对象保持不变，可能无法检索幻像引用的引用：幻像引用的get方法始终返回null，也就是说无法获取幻想引用的实例。

  为一个对象设置一个幻像引用关联的唯一目的就是能在这个对象被垃圾收集器回收时收到一个系统通知。

### 对象死亡过程

1. 当分配对象时，JVM内部会记录这个对象是finalizable（可被终结的）
2. 当垃圾回收器在进行可达性分析后发现一个对象是不可达的，并且发现这个对象是 finalizable（当分配对象时已经被记录）。则垃圾回收器将把这个对象加入到一个 finalization queue 中。它还确保保留从该对象可到达的所有其他对象，即使它们无法访问，因为它们可能被终结器访问。 
3. 稍后，JVM的 finalizer 线程会将该对象排出队列，并调用该对象的 `finalize()`方法，同时记录该对象的finalizer方法已经被调用，这是obj可以认为是finalized（已经被终结）。
4. 当垃圾收集器重新发现该对象是不可达的，收集器会回收该对象和所有从该对象可达的对象(此时该对象无法通过其他方式可达)。

如果想让一个对象在此期间逃脱死亡的机会，则需要在调用`finalize()`期间将该对象与引用链上的对象关联。

## 垃圾收集算法

### 标记—清除算法：

算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后同一回收所有被标记的对象。

不足：一个是效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记-清除过程后会产生大量的不连续的内存碎片，内存碎片太多可能会导致以后再程序运行过程中需要分配较大的对象时，无法找到足够的连续内存而不得不提前出发下一次垃圾收集动作。

### 复制算法：

复制算法将内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次对整个半区进行内存回收，内存分配时就不用考虑内存碎片等复杂情况，只要移动指针，按顺序分配内存即可。

不足：将可用内存缩小为原来的一半，代价过高。

### 标记-整理算法：

过程与标记-清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理到端边界以外的内存。

### 分代收集算法：

当前商业虚拟机都是用“分代收集算法”进行垃圾收集。这种算法根据对象生存周期的不同把java 堆分为新生代和老年代。新生带的对象生存周期短每次垃圾收集后都有大量的对象死去，只有少部分的对象存活，适用于复制算法。虚拟机将新生带分为一块较大的Eden 空间，和两块较小的 Survivor 空间。Eden 空间和 Survivor 空间默认的大小比例为 8：1 。每次垃圾收集时，都将Eden 空间和 一块 Survivor 空间上的存活对对象复制到另外一块 Survivor空间上，**每次使用的空间站新生代的 90 % 。**但Survivor的空间不够时，需要依赖老年代进行分配担保使对象进入老年代。

## 垃圾收集器:

### 什么是垃圾收集器？

垃圾收集器（GC）自动管理应用程序的动态内存分配请求。

垃圾收集器通过以下操作执行自动动态内存管理：

- 分配给操作系统并将内存返回给操作系统。
- 在请求时将内存分发给应用程序。
- 确定应用程序仍在使用该内存的哪些部分。
- 回收未使用的内存以供应用程序重用。

Java HotSpot垃圾收集器采用各种技术来提高这些操作的效率：

- 使用分代收集算法，可以将精力集中在堆中最可能包含大量可回收内存区域的区域。
- 使用多个线程积极地使操作并行，或者在后台与应用程序并发执行一些长时间运行的操作。
- 尝试通过压缩活动对象来恢复更大的连续可用内存。

### Serial收集器

该收集器是新生带的使用标记-复制算法的单线程收集器，在垃圾收集期间必须暂停其他线程(Stop The World)。

### ParNew收集器

该收集器是使用标记-复制算法的新生带多线程并行程收集器，除了使用多线程进行垃圾回收外，其他的所有特性与Serial收集器一样。

### Parallel Scavenge 收集器

以吞吐量优先为目标的使用复制算法的多线程并行收集器。可以通过参数开启自适应调节策略。

### Serial Old收集器

Serial收集器的老年版本，使用"标记-整理"算法的老年代单线程收集器。

### Parallell Old收集器

parallel Scavenge 收集器的老年代版本，使用多线程和“标记-整理”算法。

### CMS收集器

并发标记清除（CMS :Concurrent Mark Sweep）收集器专为需要更短垃圾收集暂停且能够在应用程序运行时与垃圾收集器共享处理器资源的应用程序而设计，他是使用**标记清除算法**的老年代收集器。

通常，具有相对大的长寿命数据集（大型老年代）并在具有两个或更多处理器的机器上运行的应用程序倾向于从该收集器的使用中受益。使用命令行选项启用CMS收集器`-XX:+UseConcMarkSweepGC`。

### 并发周期：

1. **初始标记（初始标记暂停）**
2. **并发标记**
3. **重新标记（备注暂停）**
4. **并发清除**

### 并发Mark Sweep收集器性能和结构

与其他可用收集器类似，CMS收集器使用分代垃圾回收算法; 因此minor和major收集都会发生。CMS收集器尝试通过使用单独的垃圾收集器线程在执行应用程序线程的同时跟踪可访问的对象来减少由于major GC而导致的暂停时间。

在每个主要收集周期中，CMS垃圾收集器会在收集开始的时候暂停用户线程，并在在垃圾收集中期再次暂停。第二次暂停往往占了两次暂停时间更久的部分。多个线程在两个暂停期间执行收集工作。一个或多个垃圾收集器线程执行收集的其余部分（包括大多数活动对象的跟踪和扫描无法访问的对象）。minor GC 可以与正在进行的主循环交错，并且以类似于并行收集器的方式完成（特别是，在minor GC 应用程序线程被停止）。

### 并发模式失败

CMS收集器使用一个或多个与应用程序线程同时运行的垃圾收集器线程，目标是在老年代填满之前完成老年代的收集。

如前所述，在正常操作中，CMS收集器在应用程序线程仍在运行时执行大部分跟踪和扫描工作，因此应用程序线程只能看到短暂的暂停。但是，**如果CMS收集器无法在老年代填满之前完成回收不可到达的对象，或者如果无法使用老边代中的可用空闲块满足分配**，然后暂停应用程序并完成收集，并停止所有应用程序线程。 这种无法完成并行垃圾收的情况集称为**并发模式失败**，表示需要调整CMS收集器参数。如果并发收集被显式垃圾收集中断（`System.gc（）`）或者为了提供诊断工具信息所需的垃圾收集，则报告并发模式中断。



### 过多的GC时间和`OutOfMemoryError`

如果在垃圾收集中花费了太多时间，CMS收集器会抛出`OutOfMemoryError`：如果超过98％的总时间花在垃圾收集上，并且回收的堆少于2％，那么会抛出`OutOfMemoryError `。

此功能旨在防止应用程序长时间运行时由于堆太小而运行缓慢或没有进度。如有必要，可以通过`-XX:-UseGCOverheadLimit`在命令行中添加选项来禁用此功能。

该策略与并行收集器中的策略相同，只是执行并发收集所花费的时间不计入98％的时间限制。换句话说，只有在应用程序停止时执行的集合才会计入过多的GC时间。此类收集通常是由于并发模式失败或显式收集请求（例如，调用`System.gc()`）。



### 并发标记扫描收集器和浮动垃圾

与Java HotSpot VM中的所有其他收集器一样，CMS收集器是一个跟踪收集器，它至少标识堆中的所有可访问对象。

Richard Jones和Rafael D. Lins在他们的出版物Garbage Collection：Algorithms for Automated Dynamic Memory中，它是一个增量更新收集器。由于应用程序线程和垃圾收集器线程在 major GC 期间并发运行，因此垃圾收集器线程跟踪的对象可能随后在时间收集过程结束时变得不可访问。这些尚未回收的无法到达的物体被称为浮动垃圾。浮动垃圾的数量取决于并发收集周期的持续时间以及应用程序的reference 更新频率（也称为突变）。此外，由于年轻代和老年代是独立收集的，每一代都是另一方的根源。作为一个粗略的指导方针，尝试将老年代的规模增加20％来容纳浮动垃圾。浮动垃圾在到下一个并发垃圾收集周期中被清除。



### CMS 暂停

CMS收集器在并发收集周期中暂停两次应用程序。第一个暂停是将根目录中可直接访问的对象（例如，来自应用程序线程堆栈和寄存器的对象引用，静态对象等）以及堆中的其他位置（例如，年轻代）标记为存活。

第一次暂停被称为`初始标记暂停`。第二个暂停在`并发跟踪阶段`结束时开始，并且在CMS收集器完成对该对象的跟踪之后，找到由于对象中引用的应用程序线程更新而导致的并发跟踪遗漏的对象。第二次暂停被称为`备注暂停`。



### 并发标记扫描收集器并发阶段

可达对象图的`并发跟踪`发生在`初始标记暂停`和`备注暂停`之间。

在并发跟踪期间，一个或多个垃圾收集器线程会与用户线程共享处理器资源。因此，即使应用程序线程即使未暂停，应用程序吞吐量也可能在这个收集阶段和其他的收集阶段中减少。备注暂停后，`并发收集阶段`会将被标记为无法访问的对象清除。收集周期完成后，CMS收集器等待，几乎不消耗任何计算资源，直到下一个主要收集周期开始。

### 启动并发收集周期

使用串行收集器时，只要老年代变满并且在收集完成时停止所有应用程序线程，就会发生 major GC。相反，CMS收集器中并发集合的开始必须定时，以便收集可以在老年代空间满了之前完成; 否则，应用程序会因并发模式故障而观察到更长的暂停。有几种方法可以启动并发收集。

根据最近的历史记录，CMS收集器维护对老年代用尽之前剩余时间的估计以及并发收集周期所需的时间。使用这些动态估计，开始并发收集周期，目的是在老年代代用尽之前完成收集周期。这些估计值是为了安全而填充的，因为并发模式故障的代价可能非常昂贵。

如果老年代的占用率超过初始占用率（老年代代的百分比），则也开始并发收集。此初始占用阈值的默认值约为92％，但该值可能会随发行版的不同而有所变化。可以使用命令行选项手动调整此值`-XX:CMSInitiatingOccupancyFraction=``<N>`，其中`<N>`是旧生成大小的整数百分比（0到100）。



### 调度暂停

年轻代收集和老年代收集的停顿独立发生。

它们不重叠，但可以快速连续发生，使得来自一个收集的暂停，一次收集紧接着上一次收集，可以看起来是单个较长的暂停。 为了避免这种情况，CMS收集器尝试在上一次和下一次年轻代暂停之间中途安排备注暂停。 目前尚未对初始标记暂停进行此调度，这通常比备注暂停短得多。

`初始标记暂停`通常相对于minor 收集暂停时间较短。并发阶段（并发标记，并发预清除）通常持续时间明显长于minor GC造成的暂停，如CMS收集器输出示例中所示。但请注意，在这些并发阶段期间不会暂停应用程序。备注暂停的长度通常与minor GC相当。备注暂停受某些应用程序特征的影响（例如，高速率的对象修改可以增加此暂停）以及自上次minor GC以来的时间（例如，年轻代中的更多对象可能会增加此暂停）。





## Garbage-First 垃圾收集器（标记-复制）

### 垃圾优先垃圾收集器简介

Garbage-First（G1）垃圾收集器的目标是具有大量内存的多处理器机器。它试图以**高概率满足垃圾收集暂停时间目标**，同时在几乎不需要配置的情况下实现高吞吐量。G1旨在实现当前目标应用程序和环境提供延迟和吞吐量之间的最佳平衡，其功能包括：

- 堆大小最多为10 GB或更大，超过50％的Java堆占用实时数据。
- 对象回收的比率和性能随着时间的推移而增多。
- 堆中存在大量碎片。
- 可预测的暂停时间目标目标，不超过几百毫秒，避免长时间的垃圾收集暂停。

G1取代了Concurrent Mark-Sweep（CMS）收集器。它也是默认的收集器。

G1收集器实现了高性能，并尝试以下面几节中描述的几种方式实现暂停时间目标。

### 启用G1

Garbage-First垃圾收集器是默认收集器，因此通常您不必执行任何其他操作。您可以通过` -XX:+UseG1GC`在命令行上提供来明确启用它。

### 基本概念

G1是使用**分代收集算法，增量的，并行的，大多数时间并发的，Stop the World的，疏散的垃圾收集器，它监视每个Stop the World 停顿的暂停时间**。与其他收集器类似，G1将堆分成（虚拟）年轻和老年代。内存回收工作集中在年轻一代，这是最有效的，老年代偶尔进行内存回收

有些操作总是在Stop the World时执行以提高吞吐量。其他需要花费更多时间停止应用程序的操作，例如全局标记等全堆操作，是与应用程序并行执行的。**为了避免内存回收的Stop the World，G1逐步并行地进行空间回收。G1通过跟踪有关先前应用程序行为和垃圾收集暂停的信息来建立相关成本模型，从而实现可预测性。**它使用此信息来确定暂停中完成的工作的大小。**例如，G1首先在最有效的区域中回收空间（即大多数区域充满垃圾，因此名称）。**

G1主要通过使用**疏散**（evacuation）来回收空间：在选定的存储区域中找到的活动对象被复制到新的存储区域中，在此过程中**压缩**它们。疏散完成后，活动对象先前占用的空间将被重新用于应用程序的分配。

Garbage-First收集器**不是实时收集器**。**它试图在较长时间内以高概率满足设定的暂停时间目标，但对于给定的暂停并不总是绝对确定。**

### 垃圾收集周期

- **初始标记**
- **并发标记**

- **最终标记**
- **筛选回收**

#### 堆布局

G1将堆分区为一组大小相等的堆区域，每个区域都是一个连续的虚拟内存区域，如图所示。区域是内存分配和内存回收的单位。在任何给定时间，这些区域中的每一个都可以是空的（浅灰色），或者分配给特定的一代，无论年轻还是年老。随着内存请求的进入，内存管理器会分发空闲区域。内存管理器将它们分配给任意一代，然后将它们作为可以自行分配的可用空间返回给应用程序。

![9-1](https://docs.oracle.com/en/java/javase/11/gctuning/img/jsgct_dt_004_grbg_frst_hp.png)

年轻一代包含伊甸园区域（红色）和幸存区域（红色与“S”）。这些区域提供与其他收集器中的相应连续空间相同的功能，不同之处在于G1中这些区域通常以不连续的方式布置在存储器中。老年代区（淡蓝色）构成了老年代。对于跨越多个区域的物体，老年代区域可能是巨大的（浅蓝色和“H”）。

应用程序总是分配给年轻一代，即伊甸园区域，除了直接分配为属于老年代的巨大对象。

G1垃圾收集暂停可以回收整个年轻代的空间，任何收集的任何其他一组老年代区域都会暂停。在暂停期间，G1会将此集合中的对象复制到堆中的一个或多个不同区域。对象的目标区域取决于该对象的源区域：整个年轻代被复制到Survivor或老年代区域，老年代被复制到其他的老年代区域。

#### 垃圾收集周期

在上半部分上，G1收集器在两个阶段之间交替。 young-only 阶段包含垃圾收集，逐渐填充当前可用内存和老年代中的对象。空间回收阶段是除了处理年轻代之外，G1逐步回收老年代的空间。然后循环重新开始，只有一个年轻阶段。

图9-2给出了有关此循环的概述，并提供了可能发生的垃圾收集暂停序列的示例：

![](https://docs.oracle.com/en/java/javase/11/gctuning/img/jsgct_dt_001_grbgcltncyl.png)



以下列表详细描述了阶段，它们的暂停以及G1垃圾收集周期阶段之间的转换：

1. Young-only 阶段：此阶段从一些正常的年轻收集开始，这些集合将对象提升到老年代。只有young-only阶段到 space-reclamation 阶段之间的过渡开始于老年代占用率达到某个阈值，即启动堆占用阈值。此时，G1开始 Concurrent Start收集 年轻集合而不是Normal年轻集合。 
   - 并发启动：除了执行Normal年轻收集之外，此类收集还会启动标记过程。并发标记确定老年代区域中当前可到达（存活）的所有对象，以便在下一个空间回收阶段保留。虽然收集标记尚未完全完成，但可能会出现正常的年轻代收集。标记完成时有两个特殊的Stop the world：备注和清理。 
   - remark：此暂停最终确定标记本身，执行全局引用处理和类卸载，回收完全空白区域并清理内部数据结构。在备注和清理之间G1计算信息以便以后能够同时回收所选旧代区域中的可用空间，这将在清理暂停中完成。
   - 清理：此暂停确定是否实际遵循空间回收阶段。如果随后是空间回收阶段，那么仅限年轻的阶段将完成一个Prepare Mixed年轻系列。 
2. 空间回收阶段：此阶段由多个混合集合组成，除了年轻代区域外，还可以回收一部分老年代区域的活动对象。当G1确定回收更多的老年代区域不会产生足够的自由空间值得努力时，空间回收阶段结束。

在空间回收之后，收集周期将以另一个仅限年轻的阶段重新开始。作为备份，如果应用程序在收集活动信息时内存不足，G1会像其他收集器一样执行 stop-the-world 全堆压缩（Full GC）。

### G1 内部

本节介绍垃圾优先（G1）垃圾收集器的一些重要细节。



#### 确定启动堆占用率

该起爆堆占有百分比（IHOP）是在该初始集合标记触发阈值，并将其定义为老年代大小的百分比。

G1默认情况下通过观察标记所花费的时间以及在标记周期期间通常在旧一代中分配多少内存来自动确定最佳IHOP。此功能称为自适应IHOP。如果此功能处于活动状态，则该选项`-XX:InitiatingHeapOccupancyPercent`将初始值确定为当前旧代的大小的百分比，只要没有足够的观察值来对启动堆占用阈值进行良好预测即可。使用选项关闭G1的此行为`-XX:-G1UseAdaptiveIHOP`。在这种情况下，值`-XX:InitiatingHeapOccupancyPercent`始终确定此阈值。

在内部，Adaptive IHOP尝试设置Initiating Heap Occupancy，以便当旧一代占用率处于当前最大旧生成大小减去`-XX:G1HeapReservePercent`作为额外缓冲区的值时，空间回收阶段的第一个混合垃圾收集开始。

#### marking

G1标记使用称为Snapshot-At-Beginning（SATB）的算法。它在初始标记暂停时获取堆的虚拟快照，此时在标记开始时生存的所有对象被认为是剩余标记的实时对象。这意味着在标记期间变为死亡（无法访问）的对象仍然被认为是用于空间回收的实时（除了一些例外）。与其他收集器相比，这可能会导致错误地保留一些额外的内存。但是，SATB可能会在备注暂停期间提供更好的延迟。在该标记期间过于保守地考虑的活动对象将在下一个标记期间被回收。请参阅[垃圾优先垃圾收集器调整](https://docs.oracle.com/en/java/javase/11/gctuning/garbage-first-garbage-collector-tuning.html#GUID-90E30ACA-8040-432E-B3A0-1E0440AB556A) 有关标记问题的更多信息的主题。



#### 在非常紧的堆情况下的行为

当应用程序保持如此多的内存以便疏散无法找到足够的空间来复制时，就会发生疏散失败。疏散失败意味着G1试图通过保留已经在新位置移动的任何对象来完成当前的垃圾收集，而不是复制任何尚未移动的对象，仅调整对象之间的引用。疏散失败可能会产生一些额外的开销，但通常应该与其他年轻的收集一样快。在此疏散失败的垃圾收集之后，G1将正常恢复应用程序而不采取任何其他措施。G1假设疏散失败发生在垃圾收集结束时; 那是，

如果这个假设不成立，那么G1最终将安排一个完整的GC。此类集合执行整个堆的就地压缩。这可能非常慢。

有关分配失败或Full GC的问题的详细信息，请参阅[垃圾优先垃圾收集器调整](https://docs.oracle.com/en/java/javase/11/gctuning/garbage-first-garbage-collector-tuning.html#GUID-90E30ACA-8040-432E-B3A0-1E0440AB556A)，然后再发出内存不足信号。

#### Humongous Objects

Humongous对象是大于或等于半个区域大小的对象。除非使用选项进行设置，否则当前区域尺寸按照符合人体工程学的方式确定，如[G1 GC](https://docs.oracle.com/en/java/javase/11/gctuning/garbage-first-garbage-collector.html#GUID-082C967F-2DAC-4B59-8A81-0CEC6EEB9016)的[人体工程学默认值](https://docs.oracle.com/en/java/javase/11/gctuning/garbage-first-garbage-collector.html#GUID-082C967F-2DAC-4B59-8A81-0CEC6EEB9016)部分所述`-XX:G1HeapRegionSize`。

这些巨大的物体有时会以特殊方式处理：

- 每个巨大的对象都被分配为老年代的一系列连续区域。对象本身的起始始终位于该序列中第一个区域的开头。在整个对象被回收之前，序列的最后一个区域中的任何剩余空间都将丢失以进行分配。
- 通常，只有在清理暂停期间标记结束时才会回收大量对象，或者如果它们无法访问则可以在完全GC期间回收。然而，对于基本类型的数组，例如` bool`各种整数和浮点值，存在对于大量对象的特殊规定。如果在任何类型的垃圾收集暂停时没有被许多对象引用，G1会机会性地尝试回收大量的对象。默认情况下启用此行为，但您可以使用该选项禁用它`-XX:G1EagerReclaimHumongousObjects`。
- 大量物体的分配可能导致垃圾收集暂停过早发生。G1检查每个巨大物体分配时的初始堆占用阈值，并且如果当前占用率超过该阈值，则可以立即强制初始标记年轻收集。
- 即使在Full GC期间，这些巨大的物体也不会移动。这可能导致过早缓慢的Full GC或意外的内存不足情况，由于区域空间的碎片而留下大量可用空间。



#### 仅年轻阶段生成大小

在仅限年轻的阶段，收集的区域集合（收集集）仅由年轻一代区域组成。G1总是将年轻一代的大小放在正常年轻集合的末尾，以用于下一个变异阶段。这样，G1可以满足使用` -XX:MaxGCPauseTimeMillis`并`-XX:PauseTimeIntervalMillis`基于实际暂停时间的长期观察设置的暂停时间目标。它考虑了年轻一代相似规模的撤离需要多长时间。这包括诸如在收集期间必须复制多少对象以及这些对象如何互连的信息。

如果没有另外约束，则G1自适应地调整年轻代之间的大小，`-XX:G1NewSizePercent`并`-XX:G1MaxNewSizePercent`确定满足暂停时间。  有关如何修复长暂停的详细信息，请参阅[垃圾优先垃圾收集器调整](https://docs.oracle.com/en/java/javase/11/gctuning/garbage-first-garbage-collector-tuning.html#GUID-90E30ACA-8040-432E-B3A0-1E0440AB556A)。



#### 空间回收阶段生成大小

在空间回收阶段，G1尝试在单个垃圾收集暂停中最大化在旧一代中回收的空间量。年轻一代的大小被设置为允许的最小值，通常由确定`-XX:G1NewSizePercent`，并且添加任何旧的回收空间区域直到G1确定添加更多区域将超过暂停时间目标。在特定的垃圾收集暂停中，G1按照其回收效率，最高的第一个以及获得最终收集集的剩余可用时间的顺序添加旧的生成区域。

每个垃圾收集所采用的旧代区域的数量在下端由要收集的潜在候选旧生成区域（收集集合候选区域）的数量除以由所确定的空间回收阶段的长度除以` -XX:G1MixedGCCountTarget`。收集集候选区域都是老年代区域，其占用率低于`-XX:G1MixedGCLiveThresholdPercent`阶段开始时的占用率。

当收集组候选区域中可回收的剩余空间量小于设定的百分比时，该阶段结束` -XX:G1HeapWastePercent`。

有关将使用多少旧生成区域G1以及如何避免长混合收集暂停的详细信息，请参阅[垃圾优先垃圾收集器调整](https://docs.oracle.com/en/java/javase/11/gctuning/garbage-first-garbage-collector-tuning.html#GUID-90E30ACA-8040-432E-B3A0-1E0440AB556A)。

### 与其他收藏家的比较

这是G1和其他收藏家之间主要差异的总结：

- **并行GC只能作为一个整体压缩和回收老年代的空间。G1逐步将这项工作分配到多个更短的收集中。这大大缩短了暂停时间，可能会降低吞吐量。**
- 与CMS类似，G1并发执行老年代空间的回收。但是，**CMS无法对老年代堆进行碎片整理，最终会遇到长的Full GC。**
- G1可能表现出比其他收集器更高的开销，由于其并发性质而影响吞吐量。

由于它的工作原理，G1有一些独特的机制来提高垃圾收集效率：

- **G1可以在任何收集过程中回收一些完全空洞的老年代区域。这可以避免许多其他不必要的垃圾收集，从而不需要太多努力就可以释放大量空间。**
- **G1可以选择同时尝试在Java堆上重复删除重复的字符串。**

始终启用从旧一代回收空的大对象。您可以使用该选项禁用此功能`-XX:-G1EagerReclaimHumongousObjects`。默认情况下禁用字符串重复数据删除。您可以使用该选项启用它` -XX:+G1EnableStringDeduplication`。

## Z垃圾收集器

Z垃圾收集器（ZGC）是一个可扩展的低延迟垃圾收集器。ZGC同时执行所有昂贵的工作，而不会停止执行应用程序线程超过10毫秒，这使得它适用于需要低延迟和/或使用非常大的堆（多兆兆字节）的应用程序。

Z垃圾收集器可用作实验性功能，并使用命令行选项启用` -XX:+UnlockExperimentalVMOptions -XX:+UseZGC`。



### 设置堆大小

ZGC最重要的调整选项是设置最大堆大小`(-Xmx)`。由于ZGC是并发收集器，因此必须选择最大堆大小，以便：1）堆可以容纳应用程序的实时集，以及2）堆中有足够的空间允许在GC处理时分配服务运行。需要多少空间取决于应用程序的分配率和实时设置大小。一般来说，你给ZGC的内存越多越好。但与此同时，浪费内存是不可取的，因此所有关于在内存使用和GC运行频率之间找到平衡点。



### 设置并发GC线程数

可能要查看的第二个调优选项是设置并发GC线程的数量`(-XX:ConcGCThreads)`。ZGC具有自动选择此编号的启发式方法。这种启发式方法通常运行良好，但根据应用程序的特性，可能需要进行调整。此选项基本上决定了应该给出多少CPU时间。给它太多，GC将从应用程序中窃取过多的CPU时间。给它太少，应用程序可能比GC可以更快地分配垃圾。

###   ZGC并发类卸载 （java 12发布）

Z垃圾收集器现在支持类卸载。通过卸载未使用的类，可以释放与这些类相关的数据结构，从而降低应用程序的总体占用空间。ZGC中的类卸载同时发生，不会停止Java应用程序线程的执行，因此对GC暂停时间没有影响。默认情况下启用此功能，但可以使用命令行选项禁用此功能`-XX:-ClassUnloading`。