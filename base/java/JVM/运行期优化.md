## 类数据共享

本章介绍了类数据共享（CDS）功能，该功能可以帮助减少Java应用程序的启动时间和内存占用量。

### 类数据共享

类数据共享（CDS）功能有助于减少多个Java虚拟机（JVM）之间的启动时间和内存占用。

使用安装程序安装Oracle Java Runtime Environment（JRE）时，安装程序会将一组默认类从系统Java Archive（JAR）文件加载到专用内部表示形式，并将该表示形式转储到称为共享存档的文件中。如果未使用JRE安装程序，则可以手动生成共享存档。

当JVM启动时，共享存档将进行内存映射，以允许在多个JVM进程之间共享这些类的只读JVM元数据。因为访问共享存档比加载类更快，所以减少了启动时间。

 G1, serial, parallel, 和parallelOldGC 垃圾收集器支持类数据共享。共享字符串功能（类数据共享的一部分）仅支持64位非Windows平台上的G1垃圾收集器。

在Java SE中包含CDS的主要动机是减少启动时间。应用程序相对于它使用的核心类数量越小，启动时间的节省部分就越大。

新JVM实例的占用空间成本有两种降低：

1. 同一主机上的共享存档的一部分映射为只读并在多个JVM进程之间共享。否则，需要在每个JVM实例中复制此数据，这会增加应用程序的启动时间。
2. 共享存档包含Java Hotspot VM使用它的表单中的类数据。不使用在运行时模块化映像中访问原始类信息所需的存储器。这些内存节省允许更多应用程序在同一系统上同时运行。在Windows应用程序中，由各种工具测量的进程的内存占用量可能会增加，因为更多页面会映射到进程的地址空间。这种增加被在运行时模块化映像上保存部分所需的内存量（Windows内部）减少所抵消。减少占地面积仍然是一个高优先级。



#### 应用程序类 - 数据共享

为了进一步减少启动时间和占用空间，引入了应用程序类 - 数据共享（ApsCDS），它扩展了CDS以包括应用程序类路径中的选定类。

此功能允许将应用程序类放在共享驱动器中。公共类元数据在不同的Java进程之间共享。AppCDS允许内置系统类加载器，内置平台类加载器和自定义类加载器来加载存档类。当多个JVM共享同一个归档文件时，将保存内存并改善整个系统响应时间。

请参见[应用类数据共享](https://www.oracle.com/pls/topic/lookup?ctx=en/java/javase/11/vm&id=JSWOR-GUID-31503FCE-93D0-4175-9B4F-F6A738B2F4C4)在Java平台，标准版工具参考。



### 重新生成共享存档

您可以为所有支持的平台重新生成共享存档。

与JRE一起安装的默认类仅包含一小组核心库类。您可能希望在共享存档中包含其他类。要从类加载跟踪输出或运行应用程序创建类列表，请输入以下命令以转储所有已加载的库类：

```
java -XX:DumpLoadedClassList=<class_list_file>
```

使用基于概要分析创建的类列表生成共享归档。

您可以在以下位置找到存档文件以及JVM的共享库：

- 在Solaris，Linux和macOS平台上，共享存档存储在 `/lib/[arch]/server/classes.jsa`
- 在Windows平台上，共享存档存储在 `/bin/server/classes.jsa`

如果存档文件存在，则在生成新存档文件时会覆盖存档文件。生成新存档之前，无需手动删除旧存档。

要重新生成存档文件，请以管理员身份登录。在联网情况下，登录到与Java SE安装相同的体系结构的计算机。确保您有权写入安装目录。

要使用用户定义的类列表重新生成共享存档，请输入以下命令：

```
java -XX:SharedClassListFile=<class_list_file> -Xshare:dump
```

生成存档时会打印诊断信息。



### 手动控制类数据共享

默认情况下启用类数据共享。您可以手动启用和禁用此功能。

您可以使用以下命令行选项进行诊断和调试。

- `-Xshare:off`

  禁用类数据共享。

- `-Xshare:on`

  启用类数据共享。如果无法启用类数据共享，请打印错误消息并退出。注意：它`-Xshare:on`仅用于测试目的，并且可能由于操作系统使用地址空间布局随机化而导致间歇性故障。不应在生产环境中使用此选项。

- `-Xshare:auto`

  默认情况下启用类数据共享。尽可能启用类数据共享。

### 压缩字符串

压缩字符串功能为字符串引入了节省空间的内部表示。

来自不同应用程序的数据表明字符串是Java堆使用的主要组成部分，并且大多数`java.lang.String`对象仅包含Latin-1字符。这些字符只需要一个字节的存储空间。结果，`java.lang.String`不使用对象的内部字符数组中的一半空间。Java SE 9中引入的紧凑字符串功能减少了内存占用，并减少了垃圾收集活动。如果您在应用程序中观察到性能回归问题，则可以禁用此功能。

压缩字符串功能不会引入新的公共API或接口。它将`java.lang.String`类的内部表示形式从UTF-16（两个字节）字符数组修改为字节数组，并使用附加字段来标识字符编码。其他字符串相关的类，如`AbstractStringBuilder`，`StringBuilder`和`StringBuffer`更新使用类似的内部表示。

在Java SE 9中，默认情况下启用紧凑字符串功能。因此，`java.lang.String`该类将字符存储为每个字符的一个字节，编码为Latin-1。附加字符编码字段表示使用的编码。HotSpot VM字符串内在函数已更新和优化，以支持内部表示。

您可以通过命令行使用该`-XX:-CompactStrings`标志来禁用紧凑字符串功能`java`。禁用该功能时，`java.lang.String`该类将字符存储为两个字节，编码为UTF-16，HotSpot VM字符串内在函数使用UTF-16编码。



### 分层编译

Java SE 7中引入的分层编译将客户端VM启动速度带入服务器VM。在没有累积编译的情况下，服务器VM使用解释器来收集有关发送到编译器的方法的分析信息。通过分层编译，服务器VM还使用客户端编译器生成方法的编译版本，以收集有关自身的分析信息。编译的代码比解释器快得多，并且程序在分析阶段执行时具有更高的性能。通常，启动速度比客户端VM启动速度快，因为服务器编译器生成的最终代码可能在应用程序初始化的早期阶段可用。分层编译还可以实现比常规服务器VM更好的峰值性能，因为，

默认情况下，为服务器VM启用分层编译。支持64位模式和[压缩普通对象指针](https://docs.oracle.com/en/java/javase/11/vm/java-hotspot-virtual-machine-performance-enhancements.html#GUID-932AD393-1C8C-4E50-8074-F81AD6FB2444)。您可以通过使用`-XX:-TieredCompilation`带有该`java`命令的标志来禁用分层编译。

为了适应使用分层编译生成的其他分析代码，代码缓存的默认大小乘以5x。为了有效地组织和管理更大的空间，使用[分段代码缓存](https://docs.oracle.com/en/java/javase/11/vm/java-hotspot-virtual-machine-performance-enhancements.html#GUID-1D9B26AD-8E0A-4771-90DA-A81A2C1F5B55)。



#### 分段代码缓存

代码缓存是Java虚拟机存储生成的本机代码的内存区域。它被组织为一个连续的内存块上的单个堆数据结构。 

代码缓存不是只有一个代码堆，而是分成多个段，每个段包含特定类型的编译代码。此分段可以更好地控制JVM内存占用，缩短编译方法的扫描时间，显着减少代码缓存的碎片，并提高性能。

代码缓存分为以下三个部分：

表5-1分段代码缓存

| 细分缓存代码 | 描述                                                         | JVM命令行参数                 |
| ------------ | ------------------------------------------------------------ | ----------------------------- |
| Non-method   | 此代码堆包含非方法代码，例如编译器缓冲区和字节码解释器。此代码类型永远保留在代码缓存中。代码堆具有3 MB的固定大小，并且剩余的代码缓存在分析的和非分析的代码堆之间均匀分布。 | `-XX:NonMethodCodeHeapSize`   |
| Profiled     | 此代码堆包含使用寿命较短的轻微优化的配置文件方法。           | `–XX:ProfiledCodeHeapSize`    |
| Non-profiled | 此代码堆包含完全优化的非分析方法，可能具有较长的生命周期。   | `-XX:NonProfiledCodeHeapSize` |



### Graal：基于Java的JIT编译器

Graal是一个用Java编写的高性能，优化，即时编译器，与Java HotSpot VM集成。它是可以从Java调用的可自定义动态编译器。

Graal的一些功能和好处包括：

- 灵活的推测优化
- 更好的内联 
- 部分逃逸分析
- Java工具和IDE支持带来的好处
- Metacircular方法，允许更严格的代码生成控制

您也可以在静态上下文中使用Graal。静态[提前编译器](https://docs.oracle.com/en/java/javase/11/vm/java-hotspot-virtual-machine-performance-enhancements.html#GUID-F33D8BD0-5C4A-4CE8-8259-FD9D73C7C7C6)基于Graal框架。

Graal是JDK构建的一部分，它作为内部模块提供`jdk.internal.vm.compiler`。它使用JVM编译器接口（JVMCI）与JVM通信。JVMCI也是JDK构建的一部分，它包含在内部模块中：`jdk.internal.vm.ci`。

要将Graal作为JIT编译器启用，请在`java`命令行上使用以下选项：

```
-XX:+UnlockExperimentalVMOptions -XX:+UseJVMCICompiler
```

注意：

Graal是一项实验性功能，仅在Linux-x64上受支持。



### 提前编译

通过在启动虚拟机之前将Java类编译为本机代码，Ahead（AOT）编译可以改善小型和大型Java应用程序的启动时间。

虽然实时（JIT）编译器速度很快，但编译大型Java程序需要时间。此外，当重复解释某些未编译的Java方法时，性能会受到影响。AOT解决了这些问题。

一个新工具

```
jaotc
```

用于AOT编译。该

```
jaotc
```

工具的语法如下：

```
jaotc <options> <list of classes or jar files>
jaotc <options> <--module name>
```

例如：

```
jaotc --output libHelloWorld.so HelloWorld.class
jaotc --output libjava.base.so --module java.base
```

该`jaotc`工具是Java安装的一部分，类似于`javac`。

在应用程序执行时指定生成的AOT库：

```
java -XX:AOTLibrary=./libHelloWorld.so,./libjava.base.so HelloWorld
```

当JVM启动时，AOT初始化代码会查找使用该

```
AOTLibrary
```

标志指定的库。如果找不到库，则为该JVM实例关闭AOT。

有关工具的详细信息，请参阅Java平台，标准版工具参考`jaotc`。

注意：

Ahead-of-Time（AOT）编译是一项实验性功能，仅在Linux-x64上受支持。



### 压缩普通对象指针

Java Hotspot用语中的普通对象指针（oop）是指向对象的托管指针。通常，oop与本机计算机指针的大小相同，在LP64系统上为64位。在ILP32系统上，最大堆大小小于4千兆字节，这对于许多应用程序来说是不够的。在LP64系统上，给定程序使用的堆可能必须比在ILP32系统上运行时大1.5倍。此要求是由于托管指针的扩展大小。内存很便宜，但是现在带宽和缓存供不应求，因此显着增加堆的大小并且仅仅超过4千兆字节的限制是不可取的。

Java堆中的托管指针指向在8字节地址边界上对齐的对象。压缩的oops表示托管指针（在Java虚拟机（JVM）软件中的许多但不是所有位置）作为来自64位Java堆基址的32位对象偏移。因为它们是对象偏移而不是字节偏移，所以oops可用于处理多达40亿个对象（不是字节），或堆大小最多约32 GB。要使用它们，必须将它们缩放8倍并添加到Java堆基址以查找它们引用的对象。使用压缩oops的对象大小与ILP32模式中的对象大小相当。

术语解码是指将32位压缩oop转换为64位本机地址并添加到托管堆中的操作。术语编码指的是逆操作。

Java SE 6u23及更高版本默认支持并启用压缩的oops。在Java SE 7中，默认情况下，对于`-Xmx`未指定的64位JVM进程以及`-Xmx`小于32千兆字节的值，将启用压缩oops 。对于早于6u23版本的JDK版本，请使用`-XX:+UseCompressedOops`带有该`java`命令的标志来启用压缩的oops。



### 基于零的压缩普通对象指针

当JVM在64位JVM进程中使用压缩普通对象指针（oops）时，JVM软件会向操作系统发送一个请求，以便从虚拟地址零开始为Java堆保留内存。如果操作系统支持这样的请求并且可以在虚拟地址零处为Java堆保留内存，则使用从零开始的压缩oops。

当使用从零开始的压缩oops时，可以从32位对象偏移量解码64位指针，而不包括Java堆基址。对于小于4千兆字节的堆大小，JVM软件可以使用字节偏移而不是对象偏移，因此也避免将偏移缩放8.将64位地址编码为32位偏移相应地是有效的。

对于最大为26千兆字节的Java堆，Solaris，Linux和Windows操作系统通常可以在虚拟地址零处分配Java堆。



### 逃逸分析

转义分析是Java HotSpot Server编译器可以分析新对象使用范围并决定是否在Java堆上分配对象的技术。

默认情况下，Java SE 6u23及更高版本支持并启用转义分析。

Java HotSpot Server编译器实现了以下描述的流不敏感转义分析算法：

```
 [Choi99] Jong-Deok Choi, Manish Gupta, Mauricio Seffano,
          Vugranam C. Sreedhar, Sam Midkiff,
          "Escape Analysis for Java", Procedings of ACM SIGPLAN
          OOPSLA  Conference, November 1, 1999
```

基于转义分析的对象的转义状态可以是以下状态之一：

- `GlobalEscape`：该对象转义方法和线程。例如，存储在静态字段中的对象，存储在转义对象的字段中，或作为当前方法的结果返回。
- `ArgEscape`：对象作为参数传递或由参数引用，但在调用期间不会全局转义。通过分析被调用方法的字节码来确定该状态。
- `NoEscape`：该对象是标量可替换对象，这意味着可以从生成的代码中删除其分配。

在转义分析之后，服务器编译器从生成的代码中消除标量可替换对象分配和关联锁。服务器编译器还消除了不全局转义的对象的锁定。它并不能代替用堆栈分配一个堆分配不逃避全局对象。

以下示例描述了转义分析的一些方案：

- 服务器编译器可能会消除某些对象分配。例如，方法生成对象的防御副本并将副本返回给调用者。

  ```
  public class Person {
    private String name;
    private int age;
    public Person(String personName, int personAge) {
      name = personName;
                  age = personAge;
    }
          
    public Person(Person p) { this(p.getName(), p.getAge()); }
    public int getName() { return name; }
    public int getAge() { return age; }
  }
  
  public class Employee {
    private Person person;
    
          // makes a defensive copy to protect against modifications by caller
          public Person getPerson() { return new Person(person) };
          
          public void printEmployeeDetail(Employee emp) {
            Person person = emp.getPerson();
            // this caller does not modify the object, so defensive copy was unnecessary
                  System.out.println ("Employee's name: " + person.getName() + "; age: "  + person.getAge());     
          }
  }       
          
  ```

  该方法制作副本以防止调用者修改原始对象。如果编译器确定`getPerson`在循环中调用该方法，则编译器会内联该方法。通过使用转义分析，当编译器确定永远不会修改原始对象时，编译器可以优化并消除调用以进行复制。

- 如果服务器编译器确定对象是线程本地的，则它可能会消除同步块（锁定省略）。例如，类的方法如同`StringBuffer`并且`Vector`是同步的，因为它们可以被不同的线程访问。但是，在大多数情况下，它们以线程本地方式使用。在使用是线程本地的情况下，编译器可以优化和删除同步块。



大多数加速Java编程语言性能的尝试都集中在应用为传统语言开发的编译技术。实时（JIT）编译器本质上是快速的传统编译器，可以将Java字节码动态转换为本机机器代码。在最终用户的机器上运行的JIT实际上执行字节码，并在第一次执行时编译每个方法。

但是，JIT编译存在一些问题。首先，因为编译器与在执行机器上的用户程序一起运行 ，所以它在编译速度方面受到严格限制：如果编译速度不是很快，那么用户将感觉到程序启动或程序的一部分显着延迟。这需要进行权衡，这使得执行高级优化变得更加困难，高级优化通常会显着降低编译性能。

其次，即使JIT有时间执行完全优化，这种优化对于Java编程语言来说也不如传统语言（如C和C ++）有效。有许多的原因：

- Java语言是动态 *安全的*，这意味着它确保程序不违反语言语义或直接访问非结构化内存。这意味着必须经常执行动态类型测试（在转换时以及存储到对象数组中时）。
- 与C ++相比，Java语言分配*堆上的*所有对象 ，其中许多对象是堆栈分配的。这意味着Java语言的对象分配率远高于C ++。此外，由于Java语言是垃圾收集的，因此它具有与C ++不同类型的内存分配开销（包括潜在的清理和写入屏障开销）。
- 在Java语言中，大多数方法调用都是 *虚拟的*（可能是多态的），并且比C ++中更常用。这意味着不仅方法调用性能更占优势，而且静态编译器优化（尤其是内联等全局优化）对于方法调用来说要难得多。许多传统优化在调用之间最有效，并且Java语言中调用之间的距离减小会显着降低此类优化的有效性，因为它们具有较小的代码段可供使用。
- 由于强大的执行动态加载类的能力，基于Java技术的程序可以随时更改。这使得执行许多类型的全局优化变得更加困难。编译器不仅必须能够检测这些优化何时因动态加载而变得无效，而且还能够在程序执行期间撤消或重做这些优化，即使它们涉及堆栈上的活动方法。这必须在不以任何方式损害或影响基于Java技术的程序执行语义的情况下完成。

因此，任何实现Java语言性能基本进步的尝试都必须为这些性能问题提供非传统的答案，而不是盲目地应用传统的编译器技术。

Java HotSpot VM体系结构通过使用自适应优化技术解决了上述Java语言性能问题。

### 热点检测

自适应优化通过利用有趣的程序属性解决了JIT编译的问题。实际上，所有程序都将大部分时间用于执行少量代码。Java HotSpot VM不是按方法编译方法，而是使用解释器立即运行程序，并在运行时分析代码以检测程序中的关键热点。然后，它将注意力集中在热点上的全局本机代码优化器上。通过避免编译不常执行的代码（大部分程序），Java HotSpot编译器可以更多地关注程序的性能关键部分，而不必增加整个编译时间。程序运行时，动态继续进行热点监控，

这种方法的一个微妙但重要的好处是，通过延迟编译直到代码已经执行了一段时间（在机器时间而不是用户时间测量），可以在代码使用的方式上收集信息，然后利用执行更智能的优化。同样，内存占用减少了。除了收集关于程序中的热点的信息之外，还收集其他类型的信息，例如关于虚拟方法调用的调用者 - 被调用者关系的数据。





### 方法内联

Java编程语言中虚拟方法调用的频率是一个重要的优化瓶颈。一旦Java HotSpot自适应优化器在执行期间收集有关程序热点的信息，它不仅将热点编译为本机代码，而且还对该代码执行大量方法内联。

内联具有重要的好处。它大大降低了方法调用的动态频率，从而节省了执行这些方法调用所需的时间。但更重要的是，内联会为优化程序生成更大的代码块。这创造了一种能够显着提高传统编译器优化效率的情况，克服了增加Java编程语言性能的主要障碍。

内联与其他代码优化是协同的，因为它使它们更有效。随着Java HotSpot编译器的成熟，对大型内联代码块进行操作的能力将为未来的一系列更高级的优化打开大门。





### 动态去优化

尽管在上一节中描述的内联是一个重要的优化，但传统上对于像Java语言这样的动态面向对象语言来说，它很难执行。此外，虽然检测热点并内联它们调用的方法很困难，但仍然不足以提供完整的Java编程语言语义。这是因为用Java语言编写的程序不仅可以动态地改变方法调用的模式，还可以动态地将新的Java代码加载到正在运行的程序中。

内联基于一种全局分析形式。动态加载使内联显着复杂化，因为它改变了程序中的全局关系。新类可能包含需要在适当位置内联的新方法。因此，即使在执行热点代码时，Java HotSpot VM也必须能够动态地去优化（然后在必要时重新优化）先前优化的热点。如果没有此功能，则无法在基于Java技术的程序上安全地执行内联。

Java HotSpot客户端和服务器编译器都完全支持动态去优化。这使得积极和乐观的优化以及诸如全速调试的其他技术（稍后描述）成为可能。





### Java HotSpot客户端编译器

Java HotSpot客户端编译器是一个简单，快速的三阶段编译器。在第一阶段，独立于平台的前端构造来自字节码的高级中间表示（HIR）。HIR使用静态单一赋值（SSA）形式来表示值，以便更容易地启用某些优化，这些优化在IR构造期间和之后执行。在第二阶段，特定于平台的后端从HIR生成低级中间表示（LIR）。最后阶段使用定制版本的线性扫描算法在LIR上执行寄存器分配，对LIR进行窥孔优化并从中生成机器代码。

重点放在从字节码中提取和保留尽可能多的信息。客户端编译器专注于本地代码质量，并且很少进行全局优化，因为这些优化通常是编译时最昂贵的。





### Java HotSpot Server编译器

服务器编译器针对典型服务器应用程序的性能配置文件进行了调整。Java HotSpot Server编译器是一个高端的完全优化编译器。它使用基于高级静态单一赋值（SSA）的IR进行优化。优化器执行所有经典优化，包括死代码消除，循环不变提升，公共子表达式消除，常量传播，全局值编号和全局代码运动。它还具有更专用于Java技术的优化，例如空检查和范围检查消除以及异常抛出路径的优化。寄存器分配器是全局图着色分配器，并充分利用RISC微处理器中常见的大寄存器集。编译器非常便携，依靠机器描述文件来描述目标硬件的所有方面。虽然编译器的JIT标准很慢，但它仍然比传统的优化编译器快得多，并且改进的代码质量通过减少编译代码的执行时间来回报编译时间。

### 编译器优化

Java HotSpot编译器支持一套高级优化，以实现传统直线程序和面向对象编程风格的高性能。其中一些优化包括：

- 深入内联和 内联潜在的虚拟调用：如上所述，客户端和服务器编译器使用方法内联结合全局分析和动态去优化来实现深度内联，从而消除大量的方法调用开销。
- *快速instanceof / checkcast*：Java HotSpot VM和编译器支持一种新技术，用于加速Java编程语言经常为类型安全所需的动态类型测试。这进一步降低了面向对象风格的编程的运行时间成本。
- *范围检查消除*：Java编程语言规范要求对每个数组访问执行数组边界检查。当编译器可以证明用于数组访问的索引在边界内时，可以消除索引边界检查。
- *循环展开*：服务器VM具有循环展开功能，这是一种标准的编译器优化，可实现更快的循环执行。循环展开增加了循环体尺寸，同时减少了迭代次数。循环展开还可以提高其他优化的效率。
- *反馈导向的优化*：在将Java字节码编译为优化的机器代码之前，服务器VM在解释器中执行程序的广泛分析。此分析数据为编译器提供了有关正在使用的数据类型，代码的热路径以及其他属性的更多信息。在某些情况下，编译器会更积极地使用此信息并乐观地优化代码。如果在运行时违反了代码的某个假定属性，则会对代码进行去优化，然后重新编译并重新优化。