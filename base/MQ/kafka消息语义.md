# 消息传递语义

---

现在我们对生产者和消费者的工作方式有了一些了解，让我们讨论Kafka在生产者和消费者之间提供的语义保证。显然，可以提供多种可能的消息传递保证：

- *最多一次-*消息可能会丢失，但永远不会重新发送。
- *至少一次-*消息永不丢失，但可以重新传递。
- *恰好一次* -这是人们真正想要的，每条消息只传递一次，也只有一次。

值得注意的是，这分为两个问题：发布消息的持久性保证和使用消息时的保证性。

许多系统声称提供“恰好一次”的交付语义，但是阅读精美印刷品很重要，这些声明中的大多数都具有误导性（例如：生产者或者消费者可能失败，或者有多个消费进程的情况，又或者写盘失败）。

Kafka的语义很简单。发布消息时，我们有一个消息被“提交”到日志的概念。提交已发布的消息后，只要复制此消息的分区的一个代理保持“活动”状态，它就不会丢失。下一节将更详细地描述已提交消息的定义，活动分区以及我们尝试处理的故障类型的描述。现在，让我们假设一个完美，无损的经纪人，并尝试了解对生产者和消费者的担保。如果生产者尝试发布消息并遇到网络错误，则无法确定此错误是在提交消息之前还是之后发生的。

在0.11.0.0之前，如果生产者未能收到指示消息已提交的响应，则除了重新发送消息外别无选择。这提供了至少一次的传递语义，因为如果原始请求实际上已经成功，则在重新发送期间可以将消息再次写入日志。从0.11.0.0开始，Kafka生产者还支持幂等交付选项，该选项保证重新发送不会导致日志中出现重复的条目。为此，代理为每个生产者分配一个ID，并使用生产者与每个消息一起发送的序列号对消息进行重复数据删除。同样从0.11.0.0开始，生产者支持使用类似于事务的语义将消息发送到多个主题分区的能力：即 要么所有消息都已成功写入，要么都不成功。主要用途是在Kafka主题之间进行一次精确处理（如下所述）。

并非所有用例都需要如此有力的保证。对于对延迟敏感的用途，我们允许生产者指定所需的耐久性等级。如果生产者指定要等待提交的消息，则可能需要10毫秒左右的时间。但是，生产者还可以指定它想要完全异步执行发送，或者仅等待领导者（但不一定是跟随者）收到消息。

现在让我们从消费者的角度来描述语义。所有副本具有完全相同的日志，但偏移量相同。使用者控制其在此日志中的位置。如果使用方从未崩溃，则可以将该位置存储在内存中，但是如果使用方失败，并且我们希望此主题分区由另一个进程接管，则新进程将需要选择一个合适的位置来开始处理。假设消费者阅读了一些消息-它具有处理消息和更新其位置的多个选项。



1. 它可以读取消息，然后将其位置保存在日志中，最后处理消息。在这种情况下，使用者进程有可能在保存其位置之后但在保存其消息处理的输出之前崩溃。在这种情况下，接管处理的过程将从保存的位置开始，即使该位置之前的一些消息尚未处理。这对应于“最多一次”的语义，因为在使用方失败消息的情况下，可能不会处理。
2. 它可以读取消息，处理消息并最终保存其位置。在这种情况下，使用者进程可能在处理消息之后但在保存其位置之前崩溃。在这种情况下，当新进程接管收到的前几条消息时，将已经进行处理。在发生用户故障时，这对应于“至少一次”语义。在许多情况下，消息具有主键，因此更新是幂等的（两次接收同一条消息只是用另一个自身副本覆盖一条记录）。



那么，一次语义（即您真正想要的东西）又如何呢？从Kafka主题消费并产生另一个主题时（例如在[Kafka Streams中）](https://kafka.apache.org/documentation/streams) 应用程序），我们可以利用上面提到的0.11.0.0中的新事务生成器功能。消费者的位置作为消息存储在主题中，因此我们可以在与接收已处理数据的输出主题相同的事务中将偏移量写入Kafka。如果交易中止，则根据其他消费者的“隔离级别”，消费者的头寸将恢复到其旧值，并且输出主题中产生的数据对其他消费者而言是不可见的。在默认的“ read_uncommitted”隔离级别中，所有消息对使用者都是可见的，即使它们是已中止的事务的一部分，但在“ read_committed”中，使用者将仅从已提交的事务中返回消息（以及所有不属于事务的消息）交易）。

当写入外部系统时，限制在于需要协调消费者的位置和实际存储为输出的位置。实现此目的的经典方法是在消费者头寸的存储与消费者输出的存储之间引入两阶段提交。但这可以通过让消费者将偏移量存储在与输出相同的位置来更简单地进行。这样做更好，因为使用者可能要写入的许多输出系统将不支持两阶段提交。例如，考虑一个 [Kafka Connect](https://kafka.apache.org/documentation/#connect)连接器，它在HDFS中填充数据以及它读取的数据的偏移量，从而确保数据和偏移量都被更新或都不更新。对于许多其他数据系统，我们也遵循类似的模式，这些数据系统需要这些更强的语义，并且这些消息的消息没有主键来允许重复数据删除。

因此，Kafka有效地支持[Kafka Streams中的](https://kafka.apache.org/documentation/streams)精确一次传递，并且当在Kafka主题之间传输和处理数据时，事务性生产者/消费者通常可用于提供精确一次传递。通常仅向其他目标系统提供一次精确交付，但需要与此类系统合作，但是Kafka提供了抵消，这使得实现此目标变得可行（另请参见[Kafka Connect](https://kafka.apache.org/documentation/#connect)）。否则，默认情况下，Kafka保证至少一次传送，并允许用户通过在处理一批消息之前禁用生产者的重试并在使用者中使用偏移来实现最大一次传送。



生产者：

![](/Users/wangfy/Desktop/kafkaproducer.jpeg)